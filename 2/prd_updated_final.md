# 📱 Unwind - Product Requirements Document (PRD)

**Owner**: Product Team  
**최종 업데이트**: 2025-12-29  
**버전**: 2.0  
**Status**: Ready for Development

---

## 1. 제품 개요

### 1.1 목적
Unwind는 목표 달성 후 죄책감 없는 휴식을 제공하는 집중력 향상 앱입니다. 하루 스케줄이 완료될 때까지 산만함을 차단하여, 사용자가 계획한 일과를 완수하고 진정한 휴식을 즐길 수 있게 합니다.

### 1.2 핵심 문제
- 스마트폰 중독으로 인한 계획된 일과 미완수
- 일도 못 끝내고 쉬어도 죄책감이 드는 악순환
- 기존 앱 차단 솔루션의 높은 우회율 (>60%)

### 1.3 핵심 목표
- **Primary**: 강력한 시스템적 제약으로 실제 집중 시간 확보
- **Secondary**: 목표 달성 후 죄책감 없는 휴식 제공
- **정량 목표**: 일일 집중 시간 1.2시간 → 2.5시간, 스케줄 완전 달성률 40% → 75%

### 1.4 성공 지표 (KPI)

| 지표 | 기준선 | 목표값 | 측정 주기 |
|------|--------|--------|-----------|
| **일일 스케줄 완전 달성률** | 40% | 75% | 일간 |
| 7일 스트릭 유지율 | 30% | 60% | 주간 |
| 앱 차단 우회율 | 60% | 15% | 주간 |
| 30일 리텐션 | 25% | 50% | 월간 |

---

## 2. 사용자 요구사항

### 2.1 타겟 페르소나

#### 페르소나: 김민수 (21세, 대학생)
- **Pain**: 과제 마감 직전까지 릴스를 보느라 밤샘 작업, 시험 기간 집중력 30% 미만
- **Needs**: 강제로 폰을 못 쓰게 하는 환경, 완료 후 죄책감 없이 휴식
- **JTBD**: "할 일을 다 끝낼 때까지 폰을 완벽히 차단해서, 밤에는 마음 편히 쉬고 싶다"

#### 페르소나: 박지영 (26세, 공무원 준비생)
- **Pain**: 독서실에서도 화장실 갈 때마다 폰 확인, 하루 순공 시간 3시간 미만
- **Needs**: 오전/오후 스케줄을 확실히 지킬 수 있는 강제성
- **JTBD**: "오늘 계획을 끝내면 저녁에 죄책감 없이 넷플릭스를 보고 싶다"

### 2.2 사용자 스토리 및 수용 기준 (AC)

#### Story 0: 사용자 인증 (신규 추가)

**As a** 앱을 처음 사용하는 사용자  
**I want** 회원가입 및 로그인을 통해 내 계정을 생성하고 싶다  
**So that** 여러 기기에서 내 스케줄과 통계를 동기화하고, 데이터를 안전하게 보관한다

**수용 기준:**
- AC1: 앱 최초 실행 시 회원가입/로그인 화면 표시
- AC2: 이메일과 비밀번호로 회원가입 가능
- AC3: 기존 계정으로 로그인 시 서버에서 스케줄 데이터 자동 동기화
- AC4: 로그인 상태는 토큰으로 유지 (재실행 시 자동 로그인)

#### Story 1: 스케줄 CRUD

**As a** 계획적인 사용자  
**I want** 스케줄을 자유롭게 추가, 수정, 삭제하고 싶다  
**So that** 나의 일정에 맞춰 유연하게 계획을 관리한다

**수용 기준:**
- AC1: `+` 버튼 클릭 시 스케줄 추가 모달 노출 (이름, 시간 입력)
- AC2: 모달 내 "최근 항목" 탭에서 최근 7일 내 사용 스케줄 선택 가능
- AC3: 7일 날짜 탭 선택 시 해당 날짜 스케줄 리스트 표시
- AC4: 스케줄 아이템 길게 누르기 시 수정/삭제 옵션 메뉴 노출
- AC5: 수정 선택 시 이름/시간 변경 후 저장, 로컬(UserDefaults) 및 서버에 즉시 반영
- AC6: 삭제 선택 시 확인 팝업 후 로컬 및 서버에서 제거

#### Story 2: 개별 스케줄 실행 및 타이머 기반 차단

**As a** 단계별 집중이 필요한 사용자  
**I want** 각 스케줄을 개별로 실행하고 설정된 시간만큼만 앱을 차단하고 싶다  
**So that** 스케줄별로 집중 시간을 관리하고, 완료 후 다음 일정으로 전환한다

**수용 기준:**
- AC1: 스케줄 탭 시 앱 차단 화면으로 전환 (스케줄 이름, 설정 시간 표시)
- AC2: "시작" 버튼 클릭 시 카운트다운 타이머 시작 및 앱 차단 활성화
- AC3: 차단 대상 앱 실행 시도 시 Shield 화면 노출 ("현재 집중 중: [스케줄명], 남은 시간: HH:MM:SS")
- AC4: "정지" 버튼 클릭 시 확인 팝업 → 확인 시 차단 해제 및 미완료 상태로 리스트 복귀
- AC5: 설정 시간 도달 시 차단 해제 + "완료!" 메시지 + 완료 상태로 변경 + 리스트 화면 복귀
- AC6: 완료 시 통계 데이터(달성 여부, 집중 시간)를 서버로 전송

#### Story 3: 올인 모드 (All-in Mode)

**As a** 목표 의식이 강한 사용자  
**I want** 오늘 계획한 모든 일이 끝날 때까지 폰을 잠그고 싶다  
**So that** 중간에 유혹에 빠지지 않고 전체 일과를 완수하며, 완료 후엔 죄책감 없이 휴식을 즐긴다

**수용 기준:**
- AC1: "올인 모드" 토글 ON 후 "시작" 클릭 시 앱 차단 화면으로 전환
- AC2: "시작" 클릭 시 전체 스케줄 개수 표시 + "모든 일정 완료 시까지 차단됩니다" 안내 + 차단 활성화
- AC3: 올인 모드 중 스케줄 탭 시 해당 스케줄 상세 화면 전환 (이름, 시간, 진행 상태)
- AC4: 개별 스케줄 상세에서 "완료" 체크 시 완료 상태 변경 + 리스트 화면 복귀
- AC5: 모든 스케줄 완료 시 "오늘 목표 달성! 이제 마음껏 즐기세요 🎉" 메시지 + 차단 해제 + 올인 모드 종료
- AC6: 차단 대상 앱 실행 시 Shield 화면 노출 ("올인 모드 진행 중. 완료: n/m")
- AC7: "정지" 클릭 시 "올인 모드를 중단하면 오늘은 실패로 기록됩니다" 경고 + 확인 시 차단 해제 + 실패 표시
- AC8: 올인 모드 완료/실패 데이터를 서버로 전송

#### Story 4: 차단 앱 설정

**As a** 맞춤 차단이 필요한 사용자  
**I want** 어떤 앱들을 차단할지 직접 선택하고 싶다  
**So that** 나에게 방해가 되는 앱만 선택적으로 차단한다

**수용 기준:**
- AC1: 설정 탭에서 "차단할 앱 관리" 메뉴 클릭 시 디바이스 앱 리스트 노출 (체크박스)
- AC2: 특정 앱 체크 시 차단 대상으로 추가 (UserDefaults에 로컬 저장)
- AC3: 이미 선택된 앱 체크 해제 시 차단 대상에서 제외
- AC4: "저장" 버튼 클릭 시 설정 저장 + "차단 앱이 업데이트되었습니다" 토스트
- AC5: 설정 탭 하단에 앱 버전 정보 표시 (예: "v1.0.0")

#### Story 5: 권한 해제 패널티 및 로그

**As a** 의지가 흔들리는 사용자  
**I want** 권한 해제 시 사유를 적고 기록이 남게 하고 싶다  
**So that** 스스로 부끄러움을 느껴 우회를 자제하고, 스스로에게 정직해지는 환경을 만든다

**수용 기준:**
- AC1: 집중 모드 중 권한 해제 후 앱 진입 시 사유 입력 팝업 강제 노출
- AC2: 사유 입력 후 제출 시 해당 날짜를 '주의/실패'로 마킹하고 스트릭 상태 업데이트
- AC3: 권한 해제 이벤트 및 사유를 서버로 전송
- AC4: 사유 기록 화면에서 "정말 해제하시겠습니까?" + "스스로에게 정직해지세요" 메시지 표시

#### Story 6: 스트릭 & 성공률 트래킹

**As a** 동기부여가 필요한 사용자  
**I want** 연속 성공 일수와 월간 달성률을 확인하고 싶다  
**So that** 성취감을 느끼고 지속적으로 목표를 달성한다

**수용 기준:**
- AC1: 메인 화면 상단에 현재 스트릭 일수 표시 (예: "🔥 7일 연속 달성")
- AC2: 통계 화면 진입 시 주간/월간 달성률 그래프 노출 (서버 데이터 기반)
- AC3: 연속 7일 달성 시 축하 메시지 및 배지 부여

#### Story 7: 데이터 동기화 (신규 추가)

**As a** 여러 기기를 사용하는 사용자  
**I want** 내 스케줄과 통계가 자동으로 동기화되길 원한다  
**So that** 어느 기기에서든 동일한 데이터를 확인하고 작업을 이어갈 수 있다

**수용 기준:**
- AC1: 앱 실행 시 네트워크 연결 시 서버에서 최신 스케줄 자동 다운로드
- AC2: 스케줄 생성/수정/삭제 시 서버로 즉시 전송 (네트워크 가능 시)
- AC3: 네트워크 없을 때는 로컬에서 정상 동작, 연결 복구 시 자동 동기화
- AC4: 동기화 실패 시 재시도 큐에 저장 후 백그라운드에서 재전송

---

## 3. 기능 요구사항

### 3.1 MSCW 우선순위

| 우선순위 | 기능 | 출시 버전 |
|----------|------|-----------|
| **Must** | 사용자 인증 (회원가입/로그인) | MVP |
| **Must** | 스케줄 CRUD | MVP |
| **Must** | 개별 스케줄 실행 + 타이머 기반 차단 | MVP |
| **Must** | 올인 모드 | MVP |
| **Must** | 차단 대상 앱 설정 | MVP |
| **Must** | 데이터 동기화 (로컬 ↔ 서버) | MVP |
| **Must** | 통계 데이터 서버 전송 | MVP |
| **Must** | 앱 버전 정보 표시 | MVP |
| **Must** | 완료 후 축하 메시지 | MVP |
| **Should** | 최근 항목 퀵 추가 | MVP |
| **Should** | 권한 해제 사유 로그 | MVP |
| **Should** | 스트릭 & 통계 화면 | MVP |
| **Should** | 오프라인 모드 지원 | MVP |
| **Could** | Apple 캘린더 연동 | v1.1 |
| **Could** | 소셜 기능 (친구, 리더보드) | v1.2 |

### 3.2 핵심 기능 상세

#### 3.2.1 사용자 인증
- **회원가입**: 이메일 + 비밀번호 → 서버에 계정 생성 → 자동 로그인
- **로그인**: 이메일 + 비밀번호 → 서버 인증 → 액세스 토큰 발급
- **토큰 관리**: 로그인 상태 유지 (Keychain 저장), 만료 시 자동 갱신
- **초기 동기화**: 로그인 성공 시 서버에서 스케줄 및 통계 데이터 다운로드

#### 3.2.2 스케줄 CRUD
- **생성**: `+` 버튼 → 모달 (이름, 시간 입력) → UserDefaults + 서버 저장
- **조회**: 7일 날짜 탭으로 전환, UserDefaults에서 로드
- **수정**: 스케줄 아이템 길게 누르기 → 수정 옵션 → 로컬 + 서버 업데이트
- **삭제**: 스케줄 아이템 길게 누르기 → 삭제 옵션 → 확인 팝업 → 로컬 + 서버 삭제
- **동기화**: 변경사항 즉시 서버 전송, 실패 시 큐에 저장 후 재시도

#### 3.2.3 개별 스케줄 실행 (타이머 기반)
- 스케줄 탭 → 앱 차단 화면 (이름, 시간 표시)
- "시작" 버튼 → 카운트다운 시작 + 앱 차단 (Screen Time API)
- "정지" 버튼 → 확인 팝업 → 중단 시 미완료 상태로 리스트 복귀
- 타이머 종료 시 → 완료 메시지 + 자동 리스트 복귀
- **통계 전송**: 완료/미완료 상태, 집중 시간을 서버로 전송

#### 3.2.4 올인 모드
- 하루 전체 스케줄을 하나의 세션으로 묶음
- 개별 스케줄 탭 시 → 상세 화면 (이름, 시간 표시)
- 스케줄 완료 체크 → 리스트 복귀
- 모든 스케줄 완료 시 → "오늘 목표 달성!" 전면 화면 + 차단 해제
- Shield 화면: "올인 모드 진행 중. 완료: n/m"
- **통계 전송**: 올인 모드 완료/실패 여부를 서버로 전송

#### 3.2.5 차단 앱 설정
- 설정 탭 → "차단할 앱 관리" 메뉴
- 디바이스 앱 리스트 (체크박스)
- 선택/해제 → 저장 → UserDefaults에 로컬 저장 (서버 전송 없음)
- 하단에 앱 버전 정보 표시 (예: "v1.0.0")

#### 3.2.6 데이터 동기화
- **앱 실행 시**: 서버에서 최신 스케줄 다운로드 → UserDefaults와 병합
- **스케줄 변경 시**: 즉시 서버로 전송, 실패 시 재시도 큐에 저장
- **충돌 해결**: Last-Write-Wins (최종 수정 시각 기준)
- **오프라인 모드**: 네트워크 없을 때 로컬 데이터로 정상 동작, 연결 복구 시 자동 동기화

#### 3.2.7 통계 데이터 수집
- **수집 항목**: 사용자별 스케줄 달성 빈도, 집중 시간, 앱 강제 종료 수
- **전송 시점**: 스케줄 완료/중단 시, 올인 모드 종료 시, 권한 해제 시
- **저장 위치**: 서버 데이터베이스 (사용자 ID와 연결)

#### 3.2.8 커스텀 차단 메시지 (Shield)
- **개별 스케줄**: "현재 집중 중: [스케줄명], 남은 시간: HH:MM:SS"
- **올인 모드**: "올인 모드 진행 중. 완료: n/m"
- **공통 부제**: "이것은 오류가 아닌 당신의 선택입니다"

---

## 4. 비기능 요구사항 (NFR)

### 4.1 성능
- Shield 화면 노출 지연 시간 ≤ 0.5초
- 스케줄 CRUD 반응 시간 ≤ 0.3초
- 백엔드 API 응답 시간 ≤ 500ms (p95)

### 4.2 신뢰성
- 재부팅/앱 강제 종료 시 차단 유지 성공률 ≥ 95%
- 타이머 정확도 오차 범위 ≤ 2초/시간
- 네트워크 장애 시 동기화 자동 재시도 (최대 3회, 지수 백오프)

### 4.3 보안 & 프라이버시
- Screen Time 권한 데이터는 로컬에서만 처리
- 스케줄 데이터는 HTTPS로 암호화 전송
- 사용자별 통계 데이터 서버 저장 (개인정보보호법 준수)
- 차단 앱 목록은 UserDefaults에만 저장 (서버 전송 없음)
- 로그인 토큰은 Keychain에 안전하게 저장

### 4.4 접근성
- VoiceOver 지원
- 다이나믹 타입 대응
- iOS 16.0 이상 지원
- iPhone 및 iPad 지원

### 4.5 UX
- 30초 스케줄 설정 약속 이행률 ≥ 80%
- 스케줄 CRUD 작업 성공률 ≥ 98%
- 동기화 실패 시 사용자에게 명확한 안내 제공

### 4.6 확장성
- 사용자당 최대 100개 스케줄 저장 가능
- 통계 데이터는 최근 1년치만 서버에 보관

---

## 5. 시스템 아키텍처 및 화면 구조

### 5.1 시스템 구성도

```
[iOS 앱]
├── 프론트엔드 (Swift/SwiftUI)
│   ├── Screen Time API (FamilyControls)
│   └── UserDefaults (로컬 저장소)
│
└── 통신 계층 (URLSession)
    └── HTTPS 통신
        ↓
[백엔드 서버]
├── Spring Boot 애플리케이션
│   ├── RESTful API
│   ├── 인증 서비스 (JWT)
│   ├── 스케줄 동기화 서비스
│   └── 통계 수집 서비스
│
└── 데이터베이스 (TBD: MySQL/PostgreSQL)
    ├── User 테이블
    ├── Schedule 테이블
    └── DailyStatistics 테이블
```

### 5.2 정보 구조 (IA)

```
[Unwind App]
├── 인증 화면 (초기 진입)
│   ├── 회원가입
│   └── 로그인
│
├── 스케줄 탭 (홈)
│   ├── 7일 날짜 탭
│   ├── 스케줄 리스트
│   │   ├── 개별 스케줄 탭 → 앱 차단 화면 (개별)
│   │   └── 길게 누르기 → 수정/삭제 옵션
│   ├── + 버튼 → 스케줄 추가 모달
│   │   └── 최근 항목 탭
│   └── 올인 모드 토글 + 시작 버튼 → 앱 차단 화면 (올인)
│
├── 통계 탭
│   ├── 스트릭 표시
│   ├── 주간/월간 달성률 (서버 데이터 기반)
│   └── 최근 7일 활동 그래프
│
└── 설정 탭
    ├── 차단할 앱 관리
    │   └── 앱 리스트 (체크박스)
    ├── 계정 정보
    └── 앱 버전 정보
```

### 5.3 주요 화면 상세

#### 5.3.1 인증 화면 (신규)
- **회원가입**: 이메일, 비밀번호, 비밀번호 확인 입력 필드
- **로그인**: 이메일, 비밀번호 입력 필드
- **하단**: "회원가입" / "로그인" 탭 전환

#### 5.3.2 스케줄 홈 화면
- **상단**: 앱 로고 + 스트릭 배지
- **날짜 탭**: 7일 가로 스크롤
- **스케줄 리스트**: 체크박스 + 이름 + 시간 표시
- **하단**: + 버튼, 올인 모드 토글
- **동기화 상태**: 네트워크 연결 시 자동 동기화, 실패 시 알림 표시

#### 5.3.3 스케줄 추가 모달
- **상단**: "새 스케줄" 제목
- **입력 필드**: 이름, 시간 (시간 피커)
- **하단 탭**: "직접 입력" / "최근 항목"

#### 5.3.4 앱 차단 화면 (개별 스케줄)
- **상단**: 스케줄 이름
- **중앙**: 카운트다운 타이머 (HH:MM:SS)
- **하단**: "시작" / "정지" 버튼

#### 5.3.5 앱 차단 화면 (올인 모드)
- **상단**: "올인 모드 활성화"
- **중앙**: "완료: n/m" + 전체 스케줄 개수
- **하단**: "시작" / "정지" 버튼

#### 5.3.6 설정 화면
- **차단할 앱 관리**: 앱 리스트 (아이콘 + 이름 + 체크박스)
- **계정 정보**: 이메일 표시, 로그아웃 버튼
- **하단**: 앱 버전 정보

---

## 6. 기술 제약 및 요구사항

### 6.1 iOS (프론트엔드)

#### 6.1.1 Screen Time API (FamilyControls)
- `DeviceActivityMonitorExtension`을 통한 백그라운드 모니터링
- 권한 해제 시 앱 복귀 시 상태 체크 및 패널티 UI 호출
- 앱스토어 심사 대응: "집중력 향상 및 목표 달성 지원" 목적 명시

#### 6.1.2 차단 화면 (Shield) 커스텀
- `ShieldConfiguration` 사용
- 개별/올인 모드별 차별화된 메시지
- 완료 시 축하 메시지

#### 6.1.3 타이머 및 백그라운드 동작
- **개별 스케줄**: `Timer` 또는 `DispatchSourceTimer`로 카운트다운 구현
- **올인 모드**: `DeviceActivityMonitor`로 스케줄 이벤트 감지
- 앱 종료 시에도 시스템 레벨 차단 유지
- 재부팅 시 권한 유지 검증 필요

#### 6.1.4 로컬 데이터 저장
- **스케줄 데이터**: UserDefaults (JSON 형태 저장)
- **차단 앱 목록**: UserDefaults
- **인증 토큰**: Keychain (보안 저장소)
- **동기화 큐**: UserDefaults (실패한 요청 저장)

### 6.2 Backend (Spring Boot)

#### 6.2.1 기술 스택
- **프레임워크**: Spring Boot 3.x
- **데이터베이스**: TBD (MySQL 또는 PostgreSQL 권장)
- **인증**: JWT (JSON Web Token)
- **통신**: RESTful API (JSON over HTTPS)
- **배포**: Docker 컨테이너 (클라우드 중립적)

#### 6.2.2 API 엔드포인트 (주요)
- **인증**: POST `/api/auth/signup`, `/api/auth/login`, `/api/auth/refresh`
- **스케줄**: GET/POST/PUT/DELETE `/api/schedules`
- **통계**: POST `/api/stats/completion`, GET `/api/stats/summary`
- **기타**: POST `/api/stats/force-quit`, POST `/api/stats/revocation`

#### 6.2.3 데이터베이스 스키마
- **User**: id, email, password (해시), createdAt, lastLoginAt
- **Schedule**: id, userId, clientId (UUID), name, duration, dateForDay, isCompleted, completedAt, createdAt, updatedAt, deletedAt
- **DailyStatistics**: id, userId, date, totalSchedules, completedSchedules, totalFocusTime, forceQuitCount, allInModeUsed, status

---

## 7. 데이터 흐름

### 7.1 스케줄 생성 플로우
1. 사용자가 앱에서 스케줄 생성 (이름, 시간 입력)
2. UserDefaults에 즉시 저장 (UUID 생성)
3. 백그라운드에서 서버로 POST 요청 전송
4. 성공 시: syncStatus = "synced" 업데이트
5. 실패 시: syncStatus = "pending" 유지, 재시도 큐에 추가

### 7.2 스케줄 완료 플로우
1. 사용자가 타이머 완료 또는 수동 완료 체크
2. UserDefaults에 완료 상태 저장
3. 통계 데이터 생성 (집중 시간, 달성 여부)
4. 서버로 POST `/api/stats/completion` 전송
5. 실패 시 재시도 큐에 저장

### 7.3 동기화 플로우
1. 앱 실행 시 네트워크 상태 확인
2. 연결됨: GET `/api/schedules?since={lastSyncTime}` 요청
3. 서버 데이터와 로컬 데이터 비교 (충돌 해결)
4. 로컬의 pending 항목 서버로 전송
5. 최종 병합 데이터를 UserDefaults에 저장

### 7.4 오프라인 → 온라인 전환
1. 네트워크 연결 감지 (Reachability 모니터링)
2. 재시도 큐에 저장된 요청 순차 전송
3. 성공한 요청은 큐에서 제거
4. 실패한 요청은 큐에 유지 (다음 재시도 대기)

---

## 8. 리스크 관리

| 리스크 | 영향도 | 확률 | 완화 방안 |
|--------|--------|------|-----------|
| 사용자가 '오류'로 오해 | 🔴 고 | 40% | Shield 화면에 명확한 안내 메시지 + 온보딩 강화 |
| Apple 앱스토어 심사 거절 | 🔴 고 | 30% | API 사용 목적 상세 소명 + 개인정보 보호 방침 명시 |
| 네트워크 장애로 동기화 실패 | 🟡 중 | 50% | 오프라인 모드 지원, 자동 재시도, 사용자에게 명확한 안내 |
| 타이머 부정확성 | 🟡 중 | 35% | 시스템 타이머 사용 + QA 강화 (오차 ≤ 2초/시간) |
| 스케줄 CRUD 복잡도 | 🟡 중 | 30% | 직관적 UI/UX 설계 + 사용자 테스트 반복 |
| 과도한 패널티로 인한 이탈 | 🟡 중 | 50% | 사유 기록으로 타협, v1.1에서 데이터 기반 조정 |
| 서버 장애로 인한 서비스 중단 | 🟡 중 | 10% | 핵심 기능(차단)은 로컬 동작, 통계만 서버 의존 |
| UserDefaults 용량 초과 | 🟢 저 | 20% | 스케줄 100개 제한, 초과 시 경고 |
| 차단 앱 설정 미사용 | 🟢 저 | 20% | 온보딩 시 기본 추천 앱 제시 |

---

## 9. 핵심 용어 정의

- **올인 모드**: 스케줄 사이 쉬는 시간 없이 하루 전체를 잠그는 모드
- **개별 스케줄 실행**: 각 스케줄을 개별로 실행하여 설정된 시간만큼만 차단하는 모드
- **Shield**: 차단된 앱 실행 시 iOS 시스템이 표시하는 커스텀 화면
- **스트릭**: 연속 성공 일수 (계획 없는 날은 유지)
- **최근 항목**: 최근 7일 내 사용한 스케줄을 빠르게 재사용하는 기능
- **CRUD**: Create(생성), Read(조회), Update(수정), Delete(삭제)
- **동기화**: 로컬(UserDefaults)과 서버(데이터베이스) 간 데이터 일치성 유지
- **오프라인 모드**: 네트워크 없이 로컬 데이터로 앱의 핵심 기능을 사용하는 상태
- **재시도 큐**: 네트워크 실패 시 요청을 임시 저장하는 로컬 큐

---

## 10. 개정 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.0 | 2025-12-28 | 최초 작성 | Product Team |
| 2.0 | 2025-12-29 | 사용자 인증, 데이터 동기화, 백엔드 연동 추가 | Product Team |

---

**문서 종료**